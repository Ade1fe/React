https://www.behance.net/gallery/190051207/Glassmorphism-Music-App-Design?tracking_source=search_projects|music+app&l=77


https://www.behance.net/gallery/191318255/Music-App-Design?tracking_source=search_projects|music+app&l=87


https://www.behance.net/gallery/190948767/Music-App-UI?tracking_source=search_projects|music+app&l=94



https://www.behance.net/gallery/147632861/OPLAE?tracking_source=search_projects|music+app+web+design&l=16



https://www.behance.net/gallery/186219933/music-app-design?tracking_source=search_projects|music+app+web+design&l=52




https://www.behance.net/gallery/166941047/Music-1-Dashboard-Web?tracking_source=search_projects|music+app+web+design&l=112




https://www.behance.net/gallery/152504999/Spotify-Web-Redesign-?tracking_source=search_projects|music+app+web+design&l=122


































import React, { useState, useEffect } from 'react';
import { FaPlayCircle } from 'react-icons/fa';
import { HeroCard } from '..';


const token = import.meta.env.VITE_TOKEN;

async function fetchWebApi(endpoint: string, method: string) {
  const res = await fetch(`https://api.spotify.com/${endpoint}`, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
    method
  });
  return await res.json();
}



async function getTopTracks() {
  return (await fetchWebApi(
    'v1/me/top/tracks?time_range=long_term&limit=5',
    'GET',
  
  )).items;
}


const HeroCarousel = () => {
  const [topTracks, setTopTracks] = useState<any[]>([])

  useEffect(() => {
    const fetchTracks = async () => {
      try {
        const tracks = await getTopTracks();
        setTopTracks(tracks);
      } catch (error) {
        console.error('Error fetching top tracks:', error);
      }
    };

    fetchTracks();
  }, []);

  return (
    <div>
      <h1>Top Tracks</h1>
      <div className="hero-carousel">
        {topTracks.map(track => (
          <HeroCard
            key={track.id}
            imageUrl={track.album.images[0]?.url} // Safely access the URL
            musicType={track.name}
            trackCount={track.artists.length}
            playIcon={FaPlayCircle}
          />
        ))}
      </div>
    </div>
  );
};

export default HeroCarousel;













import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { FaPlayCircle } from 'react-icons/fa';
import { HeroCard } from '..';

// Interface for track object
interface Track {
  id: string;
  album: {
    images: { url: string }[];
  };
  name: string;
  artists: { name: string }[];
}

const HeroCarousel = () => {
  const [genreSeeds, setGenreSeeds] = useState<string[]>([]);

  const clientId = import.meta.env.VITE_CLIENT_ID;
const clientSecret = import.meta.env.VITE_CLIENT_SECRET;


  useEffect(() => {
    // Function to fetch access token
    const fetchAccessToken = async () => {
      try {
        const response = await axios.post('https://accounts.spotify.com/api/token', null, {
          params: {
            grant_type: 'client_credentials',
          },
          headers: {
            'Authorization': `Basic ${btoa(`${clientId}:${clientSecret}`)}`,

          },
        });

        const accessToken = response.data.access_token;
        fetchGenreSeeds(accessToken);
      } catch (error) {
        console.error('Error fetching access token:', error);
      }
    };

    // Function to fetch available genre seeds
    const fetchGenreSeeds = async (accessToken: string) => {
      try {
        const response = await axios.get('https://api.spotify.com/v1/recommendations/available-genre-seeds', {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
          },
        });
        console.log(response);
        console.log(response.data);
        console.log(response.data.genres)
        setGenreSeeds(response.data.genres);
      } catch (error) {
        console.error('Error fetching genre seeds:', error);
      }
    };

    // Call the fetchAccessToken function
    fetchAccessToken();
  }, []);

  return (
    <div>
      {/* Render HeroCards for each genre */}
      {genreSeeds.map(genre => (
        <HeroCard
          key={genre}
          imageUrl={''}
          musicType={genre}
          trackCount={0}
          playIcon={FaPlayCircle}
        />
      ))}
    </div>
  );
};

export default HeroCarousel;




import axios from "axios";

// export const fetchAccessToken = async (clientId: string, clientSecret: string, fetchTopTracks: Function) => {
//   try {
//     const credentials = `${clientId}:${clientSecret}`;
//     const encodedCredentials = btoa(credentials); 
//     const response = await axios.post(
//       'https://accounts.spotify.com/api/token',
//       null,
//       {
//         params: {
//           grant_type: 'client_credentials',
//         },
//         headers: {
//           'Authorization': `Basic ${encodedCredentials}`,
//           'Content-Type': 'application/x-www-form-urlencoded',
//         },
//       }
//     );

//     const accessToken = response.data.access_token;
//     await fetchTopTracks(accessToken);
//   } catch (error) {
//     console.error('Error fetching access token:', error);
//   }
// };











// import { Box, Select } from "@chakra-ui/react";
// import { SearchBar } from "../../components";
// import axios from 'axios';
// import { useEffect, useState } from "react";
// import { fetchAccessToken } from '../../AccessToken';

// const SearchPage = () => {
//     const [searchItem, setSearchItem] = useState<any[]>([]);
//     const [loading, setLoading] = useState(true);
//     const [searchType, setSearchType] = useState("album"); // Default search type

//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 setLoading(true);
//                 const accessToken = await fetchAccessToken(clientId, clientSecret, fetchSearchItem);
//                 setLoading(false);
//             } catch (error) {
//                 console.error('Error fetching access token:', error);
//                 setLoading(false);
//             }
//         };

//         fetchData();
//     }, [clientId, clientSecret]);

//     const handleSearch = (searchTerm: string) => {
//         console.log('Performing search with term:', searchTerm);
//         // Implement your search logic here, e.g., make an API request
//     };

//     const handleTypeChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
//         setSearchType(event.target.value);
//     };

//     const fetchSearchItem = async (accessToken: string) => {
//         try {
//             const response = await axios.get(
//                 'https://api.spotify.com/v1/search',
//                 {
//                     params: {
//                         q: 'remaster%20track:Doxy%20artist:Miles%20Davis',
//                         type: searchType, // Using selected search type
//                         market: 'ES',
//                         limit: 10,
//                         offset: 5,
//                         include_external: 'audio'
//                     },
//                     headers: {
//                         'Authorization': `Bearer ${accessToken}`,
//                     },
//                 }
//             );
//             const items = response.data[searchType + "s"].items; // Assuming the response contains items based on the selected type
//             setSearchItem(items);
//         } catch (error) {
//             console.error('Error fetching search results:', error);
//         }
//     };

//     return (
//         <Box>
//             <SearchBar onSearch={handleSearch} />
//             <Select value={searchType} onChange={handleTypeChange}>
//                 <option value="album">Albums</option>
//                 <option value="track">Tracks</option>
//                 <option value="artist">Artists</option>
//             </Select>
//             <Box zIndex='9999999' className="">
//                 {/* Render your search results here */}
//                 {loading ? (
//                     <div>Loading...</div>
//                 ) : (
//                     searchItem.map((item: any) => (
//                         <div key={item.id}>{item.name}</div>
                   
//                     ))
//                 )}
//             </Box>
//         </Box>
//     );
// };

// export default SearchPage;

















// import React from 'react';
// import { Formik, Form, Field, FieldProps } from 'formik';
// import { InputGroup, InputLeftElement, Input, Button, Flex, Icon, Box } from '@chakra-ui/react';
// import { FaSearch } from 'react-icons/fa';


// interface SearchBarProps {
//   onSearch: (searchTerm: string) => void;
//   searchType: string;
//   handleTypeChange: (searchType: string) => void;
// }



// const SearchBar: React.FC<SearchBarProps> = ({ onSearch, searchType, handleTypeChange }) => {
//   const handleSubmit = (values: { searchTerm: string }, { resetForm }: { resetForm: () => void }) => {
//     onSearch(values.searchTerm);
//     resetForm();
//   };

//   return (
//     <Formik
//       initialValues={{ searchTerm: '' }}
//       onSubmit={handleSubmit}
//     >
//       <Form>
//         <Flex flexDirection={['column', 'column', 'row']} alignItems="center" w='full' gap='3' mb='6'>
//       <Box display={['grid', "flex"]} w='full' alignItems="center" gap='1'>
//       <Field name="searchTerm">
//             {({ field }: FieldProps<string>) => (
//               <InputGroup>
//                 <InputLeftElement pointerEvents="none" mt={3} ml={3}>
//                   <Icon as={FaSearch} color="gray.300" />
//                 </InputLeftElement>
//                 <Input
//                   {...field}
//                   _focus={{
//                     outline: "none",
//                   }}
//                   w='full'
//                   focusBorderColor='purple'
//                   pl='10'
//                   borderRadius='3xl'
//                   bg="#111"
//                   py={2}
//                   pr={2}
//                   type="text"
//                   placeholder="Search..."
//                 />
//               </InputGroup>
//             )}
//           </Field>

//         <Box>
//         <select className='select' value={searchType} 
//            onChange={(e) => handleTypeChange(e.target.value)} >
//             <option value="album">Albums</option>
//             <option value="track">Tracks</option>
//             <option value="artist">Artists</option>
//           </select>
//         </Box>
//       </Box>

//         <Button type="submit" px='4' py='1' borderRadius='md'  ml={6} bg='purple.800' colorScheme="teal">Search</Button>
//         </Flex>
//       </Form>
//     </Formik>
//   );
// };


// export default SearchBar;














// import{ useEffect, useState } from 'react';
// import { Box } from '@chakra-ui/react';
// import axios from 'axios';
// import { fetchAccessToken } from '../../AccessToken';
// import { TopArtistsCard } from '../../components';

// // Define an interface for the track object
// interface Track {
//     id: string;
//     album: {
//         images: { url: string }[];
//     };
//     name: string;
//     duration_ms: number;
//     artists: { name: string }[];
//     // Add other properties as needed
// }

// const TopArtists = () => {
//     const [tracks, setTracks] = useState<Track[]>([]);
//     const [artists, setArtists] = useState<Track[]>([]);
//     const [loading, setLoading] = useState(true);

//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 setLoading(true);
//                 const accessToken = await fetchAccessToken(clientId, clientSecret);
//                 const topTracksIds =  '4Lt6GXGzYsa1tgkv3nGSTm,0b6rUnRfjDuv60k5oWrCKa,4qlBvxOwFy6og73eik75Ro,580Rp3F98KrnHMdg8yoGvP,6G7Jnkix0H7nBxqjqGbD50';
//                 const response = await axios.get(
//                     `https://api.spotify.com/v1/tracks?ids=${topTracksIds}`,
//                     {
//                         headers: {
//                             'Authorization': `Bearer ${accessToken}`,
//                         },
//                     }
//                 );
//                 setTracks(response.data.tracks);
//                 setLoading(false);
//             } catch (error) {
//                 console.error('Error fetching recommended tracks:', error);
//                 setLoading(false);
//             }
//         };

//         fetchData();
//     }, [clientId, clientSecret]);
    

//     return (
//         <Box>
//             {loading ? (
//                 <div>Loading...</div>
//             ) : (
//                 <Box>
//                    {tracks.map((track, index) => (
//     <Box key={`${track.id}-${index}`} mb="4">
//         <TopArtistsCard
//             imageUrl={track.album.images[0].url}
//             artistName={track.artists[0].name}
//             noOfTracks={tracks.length}
//         />
//     </Box>
// ))}

//                 </Box>
//             )}


//         </Box>
//     );
// };

// export default TopArtists;
























// export const fetchSongsByGenre = async (genreId: string) => {
//   try {
//       const clientId = import.meta.env.VITE_CLIENT_ID;
//       const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//       const accessToken = await fetchAccessToken(clientId, clientSecret);

//       const response = await axios.get(
//           `https://api.spotify.com/v1/browse/categories/${genreId}/playlists`,
//           {
//               headers: {
//                   'Authorization': `Bearer ${accessToken}`,
//               },
//           }
//       );

//       if (!response.data || !response.data.playlists || !response.data.playlists.items) {
//           console.error('Unexpected response format:', response.data);
//           return [];
//       }

//       const playlists = response.data.playlists.items;

//       // Assuming you retrieve songs from the playlist
//       const songs = playlists.map((playlist: any) => ({
//           id: playlist.id,
//           name: playlist.name,
//           // Add more properties as needed
//       }));

//       console.log("Songs for genre ID", genreId, ":", songs);
//       return songs;
//   } catch (error) {
//       console.error('Error fetching songs:', error);
//       throw error;
//   }
// };









// import { Box, Image, Text } from '@chakra-ui/react';
// import React, { useEffect, useState } from 'react';
// import { useLocation, useNavigate, useParams } from 'react-router-dom';
// import { fetchSongsByGenre } from '../../AccessToken';

// const SongListsComp = () => {
//     const navigate = useNavigate();
//     const [songs, setSongs] = useState<any[]>([]);
//     const { genreId } = useParams<{ genreId: string }>();
//     const location = useLocation();
//     const queryParams = new URLSearchParams(location.search);
//     const name = queryParams.get('name') || 'Unknown Genre';
//     const imageUrl = queryParams.get('imageUrl');

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 if (genreId) {
//                     const fetchedSongs = await fetchSongsByGenre(genreId);
//                     setSongs(fetchedSongs);
//                 }
//             } catch (error) {
//                 console.error('Error fetching songs:', error);
//             }
//         };

//         fetchData();
//     }, [genreId]);

//     const handleSongClick = (songId: string) => {
//         // Navigate to another page with song details
//         navigate(`/song-details/${songId}`);
//     };

//     return (
//         <Box>
//             <Box className="">
//                 <Text>{name}</Text>
//                 {imageUrl && <Image src={imageUrl} alt={name} />}
//             </Box>
//             <ul>
//                 {songs.map(song => (
//                     <li key={song.id} onClick={() => handleSongClick(song.id)}>
//                         <Box display="flex" alignItems="center" mb={4}>
//                             <Image src={song.imageUrl} alt={song.name} width={100} height={100} borderRadius="md" mr={4} />
//                             <Box>
//                                 <Text fontWeight="bold">{song.name}</Text>
//                                 <Text>ID: {song.id}</Text>
//                             </Box>
//                         </Box>
//                     </li>
//                 ))}
//             </ul>
//         </Box>
//     );
// }

// export default SongListsComp;





















// export const fetchSongsInPlaylist = async (playlistId: string) => {
//   try {
//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//     const accessToken = await fetchAccessToken(clientId, clientSecret);

//     const response = await axios.get(
//       `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
//       {
//         headers: {
//           'Authorization': `Bearer ${accessToken}`,
//         },
//       }
//     );

//     if (!response.data || !response.data.items) {
//       console.error('Unexpected response format:', response.data);
//       return [];
//     }

//     const tracks = response.data.items;
//     console.log("tracks", tracks)

   

//     console.log("Songs in playlist", playlistId, ":", tracks);
//     return tracks;
//   } catch (error) {
//     console.error('Error fetching songs in playlist:', error);
//     throw error;
//   }
// };











// export const fetchSongsInPlaylist = async (playlistId: string) => {
//   try {
//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//     const accessToken = await fetchAccessToken(clientId, clientSecret);

//     const response = await axios.get(
//       `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
//       {
//         headers: {
//           'Authorization': `Bearer ${accessToken}`,
//         },
//       }
//     );

//     if (!response.data || !response.data.items) {
//       console.error('Unexpected response format:', response.data);
//       return [];
//     }

//     const tracks = response.data.items;
//     console.log("tracks", tracks);

//     const updatedTracks = tracks.map((track: any) => {
//       const imageUrl = track.track.album.images.length > 0 ? track.track.album.images[0].url : null;
//      console.log("imageurl", imageUrl);
//       return {
//         id: track.track.id,
//         name: track.track.name,
//         imageUrl: imageUrl,
//         // Add more properties as needed
//       };
//     });

//     console.log("Songs in playlist", playlistId, ":", updatedTracks);
//     return updatedTracks;
//   } catch (error) {
//     console.error('Error fetching songs in playlist:', error);
//     throw error;
//   }
// };










//accessToken.tsx

// export const fetchSongsByGenre = async (genreId: string) => {
//   try {
//       const clientId = import.meta.env.VITE_CLIENT_ID;
//       const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//       const accessToken = await fetchAccessToken(clientId, clientSecret);

//       const response = await axios.get(
//           `https://api.spotify.com/v1/browse/categories/${genreId}/playlists`,
//           {
//               headers: {
//                   'Authorization': `Bearer ${accessToken}`,
//               },
//           }
//       );

//       if (!response.data || !response.data.playlists || !response.data.playlists.items) {
//           console.error('Unexpected response format:', response.data);
//           return [];
//       }

//       const playlists = response.data.playlists.items;

//       // Fetch song images for each playlist and construct the songs array
//       const songs = await Promise.all(playlists.map(async (playlist: any) => {
//           // Fetch additional details for the playlist, including images
//           const playlistDetailsResponse = await axios.get(
//               `https://api.spotify.com/v1/playlists/${playlist.id}`,
//               {
//                   headers: {
//                       'Authorization': `Bearer ${accessToken}`,
//                   },
//               }
//           );

//           // Extract relevant data from the playlist details response
//           const playlistDetails = playlistDetailsResponse.data;

//           // Assuming playlist images are available in the playlistDetails.images array
//           const imageUrl = playlistDetails.images.length > 0 ? playlistDetails.images[0].url : null;

//           return {
//               id: playlist.id,
//               name: playlist.name,
//               imageUrl: imageUrl,
//               // Add more properties as needed
//           };
//       }));

//       console.log("Songs for genre ID", genreId, ":", songs);
//       return songs;
//   } catch (error) {
//       console.error('Error fetching songs:', error);
//       throw error;
//   }
// };







// import { Box, Image, Text } from '@chakra-ui/react';
// import { useEffect, useState } from 'react';
// import { useParams } from 'react-router-dom';
// import { fetchSongsInPlaylist } from '../../AccessToken';

// const ShowSongs = () => {
//     const { id } = useParams<{ id?: string }>();
//     const [playlistSongs, setPlaylistSongs] = useState<any[]>([]);
//     const queryParams = new URLSearchParams(location.search);
//     const name = queryParams.get('name') || 'Unknown Genre';
//     const imageUrl = queryParams.get('imageUrl');

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 if (id) {
//                     const songs = await fetchSongsInPlaylist(id);
//                     setPlaylistSongs(songs);
//                 }
//             } catch (error) {
//                 console.error('Error fetching songs in playlist:', error);
//             }
//         };

//         fetchData();
//     }, [id]);

//     return (
//         <Box>

// <Box position="relative" height={['300px', '340px', '360px',  "390px"]} marginBottom="50px">
//     <Box
//         position="absolute"
//         top="0"
//         left="0"
//         width="full"
//         height={['300px', '340px', '360px',  "390px"]} 
//         backgroundColor="rgba(0, 0, 0, 0.5)"
//         // backdropBlur="blur(10px)"
//     />
//     <Text    position="absolute"
//         top="20px"
//         left="20px" fontFamily="Protest Revolution, sans-serif" fontWeight='600'  textShadow='2px 3px purple' fontSize={['lg', 'x-large', 'xx-large']}>{name}</Text>
//     {imageUrl && <Image src={imageUrl} alt={name} height="full" width="full" objectFit="cover" />}
// </Box>

//             {playlistSongs.map((song: any, index: number) => (
//                 <Box key={index} display="flex" alignItems="center" mb={4}>
//                     {/* Check if imageUrl exists before rendering Image component */}
//                     {song.imageUrl && <Image src={song.imageUrl} alt={song.name} width={100} height={100} borderRadius="md" mr={4} />}
//                     <Box>
//                         <Text fontWeight="bold">{song.name}</Text>
//                         <Text>ID: {song.id}</Text>
//                         {/* Check if primaryColor is not null before rendering */}
//                         {song.primaryColor && <Text>Primary Color: {song.primaryColor}</Text>}
//                     </Box>
//                 </Box>
//             ))}

//         </Box>
//     );
// }

// export default ShowSongs;




















// import { Box, Image, Text, Table, Thead, Tbody, Tr, Th, Td } from '@chakra-ui/react';
// import { useEffect, useState } from 'react';
// import { useParams } from 'react-router-dom';
// import { fetchSongsInPlaylist } from '../../AccessToken';


// const ShowSongs = () => {
//     const { id } = useParams<{ id?: string }>();
//     const [playlistSongs, setPlaylistSongs] = useState<any[]>([]);
//     const queryParams = new URLSearchParams(location.search);
//     const name = queryParams.get('name') || 'Unknown Genre';
//     const imageUrl = queryParams.get('imageUrl');

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 if (id) {
//                     const songs = await fetchSongsInPlaylist(id);
//                     setPlaylistSongs(songs);
//                     console.log("song-lists: " ,songs.album);
//                     // console.log("Tracks:", tracks);

//                 }
//             } catch (error) {
//                 console.error('Error fetching songs in playlist:', error);
//             }
//         };

//         fetchData();
//     }, [id]);

//     return (
//         <Box>
//             <Box position="relative" height={['300px', '340px', '360px',  "390px"]} marginBottom="50px">
//                 <Box
//                     position="absolute"
//                     top="0"
//                     left="0"
//                     width="full"
//                     height={['300px', '340px', '360px',  "390px"]} 
//                     backgroundColor="rgba(0, 0, 0, 0.5)"
//                 />
//                 <Text
//                     position="absolute"
//                     top="20px"
//                     left="20px"
//                     fontFamily="Protest Revolution, sans-serif"
//                     fontWeight='600'
//                     textShadow='2px 3px purple'
//                     fontSize={[ 'xx-large', 'xxx-large', '50px']}
//                 >
//                     {name}
//                 </Text>
//                 {imageUrl && <Image src={imageUrl} alt={name} height="full" width="full" objectFit="cover" />}
//             </Box>


//             <Box textAlign="left" bg="#000" overflowX="scroll"> 
//             <Table   w={['800px', '1000px', '1200px', "1400px"]} mx='auto'  textAlign='left' bg='#000' overflowX="scroll">
//                 <Thead bg='#000'>
//                     <Tr bg='#000'>
//                         {/* <Th>Image</Th> */}
//                         <Th py='2'>Title</Th>
//                         <Th py='2'>Album</Th>
//                         <Th py='2'>Artists</Th>
//                         <Th py='2'> Duration</Th>
//                     </Tr>
//                 </Thead>
//                 <Tbody mt='200px'>
//                     {playlistSongs.map((song: any, index: number) => (
//                         <Tr key={index} my='2'>
//                             {/* <Td>
//                                 {song.imageUrl && <Image borderRadius='2xl' my='2' src={song.imageUrl} alt={song.name} height="70px" width="70px" objectFit="cover" />}
//                             </Td> */}
//                             <Td display='flex' alignItems='center' gap='3' >
//                             {song.imageUrl && <Image borderRadius='2xl' my='2' src={song.imageUrl} alt={song.name} height="70px" width="70px" objectFit="cover" />}
//                                 {song.name}
//                                 </Td>
//                             <Td>{song.album}</Td>
//                             <Td>{song.artists}</Td>
//                             <Td>{msToMinutesAndSeconds(song.duration)}</Td>
//                         </Tr>
//                     ))}
//                 </Tbody>
//             </Table>
//             </Box>

//         </Box>
//     );
// }

// // Function to convert milliseconds to minutes and seconds
// function msToMinutesAndSeconds(duration: number) {
//     const minutes = Math.floor(duration / 60000);
//     const seconds = ((duration % 60000) / 1000).toFixed(0);
//     return `${minutes}:${(parseInt(seconds) < 10 ? '0' : '')}${seconds}`;
// }

// export default ShowSongs;















// import { Box, Image, Text, Table, Thead, Tbody, Tr, Th, Td } from '@chakra-ui/react';
// import { useEffect, useState } from 'react';
// import { useNavigate, useParams } from 'react-router-dom';
// import { fetchAccessToken, fetchSongsInPlaylist } from '../../AccessToken';
// import axios from 'axios';


// const ShowSongs = () => {
//     const navigate = useNavigate();
//     const { id } = useParams<{ id?: string }>();
//     const [playlistSongs, setPlaylistSongs] = useState<any[]>([]);
//     const queryParams = new URLSearchParams(location.search);
//     const name = queryParams.get('name') || 'Unknown Genre';
//     const imageUrl = queryParams.get('imageUrl');

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 if (id) {
//                     const songs = await fetchSongsInPlaylist(id);
//                     setPlaylistSongs(songs);
//                 }
//             } catch (error) {
//                 console.error('Error fetching songs in playlist:', error);
//             }
//         };

//         fetchData();
//     }, [id]);

//     // const handleItemClick = (song: any) => {
//     //     const { id, name, imageUrl } = song;
//     //     navigate(`/dashboard/show-details/${id}?name=${encodeURIComponent(name)}&imageUrl=${encodeURIComponent(imageUrl)}`, { state: { playlistSongs } });
//     //     console.log("Clicked Song:", song.name);
//     //     console.log("Image URL:", song.imageUrl);
//     //     console.log("Audio URL:", song.audioUrl);
//     //     // Log related songs or artists here
//     // };

//     const handleItemClick = async (songId: string) => {
//         try {
//             const clientId = import.meta.env.VITE_CLIENT_ID;
//             const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//             const accessToken = await fetchAccessToken(clientId, clientSecret);
//             const response = await axios.get(`https://api.spotify.com/v1/tracks/${songId}`, {
//                 headers: {
//                     'Authorization': `Bearer ${accessToken}`
//                 }
//             });
//             const { name, album, external_urls } = response.data;
//             const imageUrl = album.images[0]?.url;
//             const audioUrl = external_urls?.spotify;
//             console.log("Clicked Song:", name);
//             console.log("Image URL:", imageUrl);
//             console.log("Audio URL:", audioUrl);
//         } catch (error) {
//             console.error('Error fetching song details:', error);
//         }
//     };

//     return (
//         <Box>
//             <Box position="relative" height={['300px', '340px', '360px',  "390px"]} marginBottom="50px">
//                 <Box
//                     position="absolute"
//                     top="0"
//                     left="0"
//                     width="full"
//                     height={['300px', '340px', '360px',  "390px"]} 
//                     backgroundColor="rgba(0, 0, 0, 0.5)"
//                 />
//                 <Text
//                     position="absolute"
//                     top="20px"
//                     left="20px"
//                     fontFamily="Protest Revolution, sans-serif"
//                     fontWeight='600'
//                     textShadow='2px 3px purple'
//                     fontSize={[ 'xx-large', 'xxx-large', '50px']}
//                 >
//                     {name}
//                 </Text>
//                 {imageUrl && <Image src={imageUrl} alt={name} height="full" width="full" objectFit="cover" />}
//             </Box>


//             <Box textAlign="left" bg="#000" overflowX="scroll"> 
//             <Table   w={['800px', '1000px', '1200px', "1400px"]} mx='auto'  textAlign='left' bg='#000' overflowX="scroll">
//                 <Thead bg='#000'>
//                     <Tr bg='#000'>
//                         {/* <Th>Image</Th> */}
//                         <Th py='2'>Title</Th>
//                         <Th py='2'>Album</Th>
//                         <Th py='2'>Artists</Th>
//                         <Th py='2'> Duration</Th>
//                     </Tr>
//                 </Thead>
//                 <Tbody mt='200px'>
//                     {playlistSongs.map((song: any, index: number) => (
//                         <Tr key={index} my='2'  onClick={() => handleItemClick(song)}>
//                             {/* <Td>
//                                 {song.imageUrl && <Image borderRadius='2xl' my='2' src={song.imageUrl} alt={song.name} height="70px" width="70px" objectFit="cover" />}
//                             </Td> */}
//                             <Td display='flex' alignItems='center' gap='3' >
//                             {song.imageUrl && <Image borderRadius='2xl' my='2' src={song.imageUrl} alt={song.name} height="70px" width="70px" objectFit="cover" />}
//                                 {song.name}
//                                 </Td>
//                             <Td>{song.album}</Td>
//                             <Td>{song.artists}</Td>
//                             <Td>{msToMinutesAndSeconds(song.duration)}</Td>
//                         </Tr>
//                     ))}
//                 </Tbody>
//             </Table>
//             </Box>

//         </Box>
//     );
// }

// // Function to convert milliseconds to minutes and seconds
// function msToMinutesAndSeconds(duration: number) {
//     const minutes = Math.floor(duration / 60000);
//     const seconds = ((duration % 60000) / 1000).toFixed(0);
//     return `${minutes}:${(parseInt(seconds) < 10 ? '0' : '')}${seconds}`;
// }

// export default ShowSongs;











// import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';



// // Wrapper function to handle rate limiting
// const rateLimitedRequest = async (config: AxiosRequestConfig): Promise<AxiosResponse> => {
//   try {
//     const response = await axios(config);
//     return response;
//   } catch (error:any) {
//     if (error.response && error.response.status === 429) {
//       // If status code is 429, retry after the specified time
//       const retryAfter = error.response.headers['retry-after'];
//       if (retryAfter) {
//         const delayTime = parseInt(retryAfter, 10) * 1000; // Convert to milliseconds
//         await delay(delayTime);
//         // Retry the request
//         return rateLimitedRequest(config);
//       }
//     }
//     // For other errors or if retry-after header is not present, re-throw the error
//     throw error;
//   }
// };

// // Define a function to delay requests
// const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// export const fetchAccessToken = async (clientId: string, clientSecret: string, fetchTopTracks?: Function) => {
//   try {
//     const credentials = `${clientId}:${clientSecret}`;
//     const encodedCredentials = btoa(credentials); 
//     const response = await axios.post(
//       'https://accounts.spotify.com/api/token',
//       null,
//       {
//         params: {
//           grant_type: 'client_credentials',
//         },
//         headers: {
//           'Authorization': `Basic ${encodedCredentials}`,
//           'Content-Type': 'application/x-www-form-urlencoded',
//         },
//       }
//     );

//     const accessToken = response.data.access_token;
//     if (fetchTopTracks) {
//       await fetchTopTracks(accessToken);
//     }
//     return accessToken;
//   } catch (error) {
//     console.error('Error fetching access token:', error);
//     throw error; 
//   }
// };


// const saveToLocalStorage = (key: string, data: any) => {
//   localStorage.setItem(key, JSON.stringify(data));
// };


// const getFromLocalStorage = (key: string) => {
//   const data = localStorage.getItem(key);
//   return data ? JSON.parse(data) : null;
// };







// interface Genre {
//     id: string;
//     name: string;
//     imageUrl: string;
// }

// export const fetchGenres = async (): Promise<Genre[]> => {
//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;

//     try {
//         const accessToken = await fetchAccessToken(clientId, clientSecret);
//         const response = await axios.get(
//             'https://api.spotify.com/v1/browse/categories',
//             {
//                 headers: {
//                     'Authorization': `Bearer ${accessToken}`,
//                 },
//             }
//         );

//         const genres: Genre[] = response.data.categories.items.map((item: any) => ({
//             id: item.id,
//             name: item.name,
//             imageUrl: item.icons.length > 0 ? item.icons[0].url : '',
//         }));
//         console.log("", genres);

//          saveToLocalStorage('genres', genres);
//         return genres;
//     } catch (error) {
//         console.error('Error fetching genres:', error);
//         return [];
//     }
// };







// export const fetchSongsByGenre = async (genreId: string) => {
//   try {
//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//     const accessToken = await fetchAccessToken(clientId, clientSecret);

//     const response = await axios.get(
//       `https://api.spotify.com/v1/browse/categories/${genreId}/playlists`,
//       {
//         headers: {
//           'Authorization': `Bearer ${accessToken}`,
//         },
//       }
//     );

//     if (!response.data || !response.data.playlists || !response.data.playlists.items) {
//       console.error('Unexpected response format:', response.data);
//       return [];
//     }

//     const playlists = response.data.playlists.items;

//     // Fetch song images for each playlist and construct the songs array
//     const songs = await Promise.all(playlists.map(async (playlist: any) => {
//       // Fetch additional details for the playlist, including images
//       const playlistDetailsResponse = await axios.get(
//         `https://api.spotify.com/v1/playlists/${playlist.id}`,
//         {
//           headers: {
//             'Authorization': `Bearer ${accessToken}`,
//           },
//         }
//       );

//       // Extract relevant data from the playlist details response
//       const playlistDetails = playlistDetailsResponse.data;

//       // Assuming playlist images are available in the playlistDetails.images array
//       const imageUrl = playlistDetails.images.length > 0 ? playlistDetails.images[0].url : null;

//       return {
//         id: playlist.id,
//         name: playlist.name,
//         imageUrl: imageUrl,
//         // Add more properties as needed
//       };
//     }));

//     saveToLocalStorage('songs', { [genreId]: songs });
//     console.log("Songs for genre ID", genreId, ":", songs);
//     return songs;
//   } catch (error) {
//     console.error('Error fetching songs:', error);
//     throw error;
//   }
// };





// // export const fetchSongsInPlaylist = async (playlistId: string) => {
// //   try {
// //     const clientId = import.meta.env.VITE_CLIENT_ID;
// //     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
// //     const accessToken = await fetchAccessToken(clientId, clientSecret);

// //     const response = await axios.get(
// //       `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
// //       {
// //         headers: {
// //           'Authorization': `Bearer ${accessToken}`,
// //         },
// //       }
// //     );

// //     if (!response.data || !response.data.items) {
// //       console.error('Unexpected response format:', response.data);
// //       return [];
// //     }

// //     const tracks = response.data.items;
// //     console.log("tracks", tracks);

// //     const updatedTracks = tracks.map((track: any) => {
// //       const album = track.track.album; // Access the album object
// //       const imageUrl = album.images && album.images.length > 0 ? album.images[0].url : null; // Check if album has images
// //      console.log("alblum", album);
// //       return {
// //         id: track.track.id,
// //         name: track.track.name,
// //         imageUrl: imageUrl,
// //         // Add more properties as needed
// //       };
// //     });
// // // Save tracks to localStorage
// //     saveToLocalStorage('playlistTracks', { [playlistId]: updatedTracks });
// //     console.log("Songs in playlist", playlistId, ":", updatedTracks);
// //     return updatedTracks;
// //   } catch (error) {
// //     console.error('Error fetching songs in playlist:', error);
// //     throw error;
// //   }
// // };







// export const fetchSongsInPlaylist = async (playlistId: string) => {
//   try {
//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//     const accessToken = await fetchAccessToken(clientId, clientSecret);

//     const response = await axios.get(
//       `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
//       {
//         headers: {
//           'Authorization': `Bearer ${accessToken}`,
//         },
//       }
//     );

//     if (!response.data || !response.data.items) {
//       console.error('Unexpected response format:', response.data);
//       return [];
//     }

//     const tracks = response.data.items;

//     const updatedTracks = tracks.map((track: any) => {
//       const album = track.track.album;
//       const imageUrl = album.images && album.images.length > 0 ? album.images[0].url : null;
//       const artists = track.track.artists.map((artist: any) => artist.name);
//       const duration_ms = track.track.duration_ms;
//       const name = track.track.name;
    
//       return {
//         id: track.track.id,
//         name: name,
//         imageUrl: imageUrl,
//         duration: duration_ms,
//         artists: artists,
//         album: album.name // Assuming you want the album name
//         // Add more properties as needed
//       };
//     });
    
//     console.log("Tracks:", tracks);


//     // Save tracks to localStorage
//     saveToLocalStorage('playlistTracks', { [playlistId]: updatedTracks });
//     console.log("Songs in playlist", playlistId, ":", updatedTracks);
//     return updatedTracks;
//   } catch (error) {
//     console.error('Error fetching songs in playlist:', error);
//     throw error;
//   }
// };









// export const fetchSongsInPlaylist = async (playlistId: string) => {
//   try {
//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//     const accessToken = await fetchAccessToken(clientId, clientSecret);

//     const response = await axios.get(
//       `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
//       {
//         headers: {
//           'Authorization': `Bearer ${accessToken}`,
//         },
//       }
//     );

//     if (!response.data || !response.data.items) {
//       console.error('Unexpected response format:', response.data);
//       return [];
//     }

//     const tracks = response.data.items;
//     console.log("tracks", tracks);

//     const updatedTracks = tracks.map((track: any) => {
//       const album = track.track.album; // Access the album object
//       const imageUrl = album.images && album.images.length > 0 ? album.images[0].url : null; // Check if album has images
//      console.log("alblum", album);
//       return {
//         id: track.track.id,
//         name: track.track.name,
//         imageUrl: imageUrl,
//         // Add more properties as needed
//       };
//     });
// // Save tracks to localStorage
//     saveToLocalStorage('playlistTracks', { [playlistId]: updatedTracks });
//     console.log("Songs in playlist", playlistId, ":", updatedTracks);
//     return updatedTracks;
//   } catch (error) {
//     console.error('Error fetching songs in playlist:', error);
//     throw error;
//   }
// };































