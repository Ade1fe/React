https://www.behance.net/gallery/190051207/Glassmorphism-Music-App-Design?tracking_source=search_projects|music+app&l=77


https://www.behance.net/gallery/191318255/Music-App-Design?tracking_source=search_projects|music+app&l=87


https://www.behance.net/gallery/190948767/Music-App-UI?tracking_source=search_projects|music+app&l=94



https://www.behance.net/gallery/147632861/OPLAE?tracking_source=search_projects|music+app+web+design&l=16



https://www.behance.net/gallery/186219933/music-app-design?tracking_source=search_projects|music+app+web+design&l=52




https://www.behance.net/gallery/166941047/Music-1-Dashboard-Web?tracking_source=search_projects|music+app+web+design&l=112




https://www.behance.net/gallery/152504999/Spotify-Web-Redesign-?tracking_source=search_projects|music+app+web+design&l=122


































import React, { useState, useEffect } from 'react';
import { FaPlayCircle } from 'react-icons/fa';
import { HeroCard } from '..';


const token = import.meta.env.VITE_TOKEN;

async function fetchWebApi(endpoint: string, method: string) {
  const res = await fetch(`https://api.spotify.com/${endpoint}`, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
    method
  });
  return await res.json();
}



async function getTopTracks() {
  return (await fetchWebApi(
    'v1/me/top/tracks?time_range=long_term&limit=5',
    'GET',
  
  )).items;
}


const HeroCarousel = () => {
  const [topTracks, setTopTracks] = useState<any[]>([])

  useEffect(() => {
    const fetchTracks = async () => {
      try {
        const tracks = await getTopTracks();
        setTopTracks(tracks);
      } catch (error) {
        console.error('Error fetching top tracks:', error);
      }
    };

    fetchTracks();
  }, []);

  return (
    <div>
      <h1>Top Tracks</h1>
      <div className="hero-carousel">
        {topTracks.map(track => (
          <HeroCard
            key={track.id}
            imageUrl={track.album.images[0]?.url} // Safely access the URL
            musicType={track.name}
            trackCount={track.artists.length}
            playIcon={FaPlayCircle}
          />
        ))}
      </div>
    </div>
  );
};

export default HeroCarousel;













import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { FaPlayCircle } from 'react-icons/fa';
import { HeroCard } from '..';

// Interface for track object
interface Track {
  id: string;
  album: {
    images: { url: string }[];
  };
  name: string;
  artists: { name: string }[];
}

const HeroCarousel = () => {
  const [genreSeeds, setGenreSeeds] = useState<string[]>([]);

  const clientId = import.meta.env.VITE_CLIENT_ID;
const clientSecret = import.meta.env.VITE_CLIENT_SECRET;


  useEffect(() => {
    // Function to fetch access token
    const fetchAccessToken = async () => {
      try {
        const response = await axios.post('https://accounts.spotify.com/api/token', null, {
          params: {
            grant_type: 'client_credentials',
          },
          headers: {
            'Authorization': `Basic ${btoa(`${clientId}:${clientSecret}`)}`,

          },
        });

        const accessToken = response.data.access_token;
        fetchGenreSeeds(accessToken);
      } catch (error) {
        console.error('Error fetching access token:', error);
      }
    };

    // Function to fetch available genre seeds
    const fetchGenreSeeds = async (accessToken: string) => {
      try {
        const response = await axios.get('https://api.spotify.com/v1/recommendations/available-genre-seeds', {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
          },
        });
        console.log(response);
        console.log(response.data);
        console.log(response.data.genres)
        setGenreSeeds(response.data.genres);
      } catch (error) {
        console.error('Error fetching genre seeds:', error);
      }
    };

    // Call the fetchAccessToken function
    fetchAccessToken();
  }, []);

  return (
    <div>
      {/* Render HeroCards for each genre */}
      {genreSeeds.map(genre => (
        <HeroCard
          key={genre}
          imageUrl={''}
          musicType={genre}
          trackCount={0}
          playIcon={FaPlayCircle}
        />
      ))}
    </div>
  );
};

export default HeroCarousel;




import axios from "axios";

// export const fetchAccessToken = async (clientId: string, clientSecret: string, fetchTopTracks: Function) => {
//   try {
//     const credentials = `${clientId}:${clientSecret}`;
//     const encodedCredentials = btoa(credentials); 
//     const response = await axios.post(
//       'https://accounts.spotify.com/api/token',
//       null,
//       {
//         params: {
//           grant_type: 'client_credentials',
//         },
//         headers: {
//           'Authorization': `Basic ${encodedCredentials}`,
//           'Content-Type': 'application/x-www-form-urlencoded',
//         },
//       }
//     );

//     const accessToken = response.data.access_token;
//     await fetchTopTracks(accessToken);
//   } catch (error) {
//     console.error('Error fetching access token:', error);
//   }
// };











// import { Box, Select } from "@chakra-ui/react";
// import { SearchBar } from "../../components";
// import axios from 'axios';
// import { useEffect, useState } from "react";
// import { fetchAccessToken } from '../../AccessToken';

// const SearchPage = () => {
//     const [searchItem, setSearchItem] = useState<any[]>([]);
//     const [loading, setLoading] = useState(true);
//     const [searchType, setSearchType] = useState("album"); // Default search type

//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 setLoading(true);
//                 const accessToken = await fetchAccessToken(clientId, clientSecret, fetchSearchItem);
//                 setLoading(false);
//             } catch (error) {
//                 console.error('Error fetching access token:', error);
//                 setLoading(false);
//             }
//         };

//         fetchData();
//     }, [clientId, clientSecret]);

//     const handleSearch = (searchTerm: string) => {
//         console.log('Performing search with term:', searchTerm);
//         // Implement your search logic here, e.g., make an API request
//     };

//     const handleTypeChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
//         setSearchType(event.target.value);
//     };

//     const fetchSearchItem = async (accessToken: string) => {
//         try {
//             const response = await axios.get(
//                 'https://api.spotify.com/v1/search',
//                 {
//                     params: {
//                         q: 'remaster%20track:Doxy%20artist:Miles%20Davis',
//                         type: searchType, // Using selected search type
//                         market: 'ES',
//                         limit: 10,
//                         offset: 5,
//                         include_external: 'audio'
//                     },
//                     headers: {
//                         'Authorization': `Bearer ${accessToken}`,
//                     },
//                 }
//             );
//             const items = response.data[searchType + "s"].items; // Assuming the response contains items based on the selected type
//             setSearchItem(items);
//         } catch (error) {
//             console.error('Error fetching search results:', error);
//         }
//     };

//     return (
//         <Box>
//             <SearchBar onSearch={handleSearch} />
//             <Select value={searchType} onChange={handleTypeChange}>
//                 <option value="album">Albums</option>
//                 <option value="track">Tracks</option>
//                 <option value="artist">Artists</option>
//             </Select>
//             <Box zIndex='9999999' className="">
//                 {/* Render your search results here */}
//                 {loading ? (
//                     <div>Loading...</div>
//                 ) : (
//                     searchItem.map((item: any) => (
//                         <div key={item.id}>{item.name}</div>
                   
//                     ))
//                 )}
//             </Box>
//         </Box>
//     );
// };

// export default SearchPage;

















// import React from 'react';
// import { Formik, Form, Field, FieldProps } from 'formik';
// import { InputGroup, InputLeftElement, Input, Button, Flex, Icon, Box } from '@chakra-ui/react';
// import { FaSearch } from 'react-icons/fa';


// interface SearchBarProps {
//   onSearch: (searchTerm: string) => void;
//   searchType: string;
//   handleTypeChange: (searchType: string) => void;
// }



// const SearchBar: React.FC<SearchBarProps> = ({ onSearch, searchType, handleTypeChange }) => {
//   const handleSubmit = (values: { searchTerm: string }, { resetForm }: { resetForm: () => void }) => {
//     onSearch(values.searchTerm);
//     resetForm();
//   };

//   return (
//     <Formik
//       initialValues={{ searchTerm: '' }}
//       onSubmit={handleSubmit}
//     >
//       <Form>
//         <Flex flexDirection={['column', 'column', 'row']} alignItems="center" w='full' gap='3' mb='6'>
//       <Box display={['grid', "flex"]} w='full' alignItems="center" gap='1'>
//       <Field name="searchTerm">
//             {({ field }: FieldProps<string>) => (
//               <InputGroup>
//                 <InputLeftElement pointerEvents="none" mt={3} ml={3}>
//                   <Icon as={FaSearch} color="gray.300" />
//                 </InputLeftElement>
//                 <Input
//                   {...field}
//                   _focus={{
//                     outline: "none",
//                   }}
//                   w='full'
//                   focusBorderColor='purple'
//                   pl='10'
//                   borderRadius='3xl'
//                   bg="#111"
//                   py={2}
//                   pr={2}
//                   type="text"
//                   placeholder="Search..."
//                 />
//               </InputGroup>
//             )}
//           </Field>

//         <Box>
//         <select className='select' value={searchType} 
//            onChange={(e) => handleTypeChange(e.target.value)} >
//             <option value="album">Albums</option>
//             <option value="track">Tracks</option>
//             <option value="artist">Artists</option>
//           </select>
//         </Box>
//       </Box>

//         <Button type="submit" px='4' py='1' borderRadius='md'  ml={6} bg='purple.800' colorScheme="teal">Search</Button>
//         </Flex>
//       </Form>
//     </Formik>
//   );
// };


// export default SearchBar;














// import{ useEffect, useState } from 'react';
// import { Box } from '@chakra-ui/react';
// import axios from 'axios';
// import { fetchAccessToken } from '../../AccessToken';
// import { TopArtistsCard } from '../../components';

// // Define an interface for the track object
// interface Track {
//     id: string;
//     album: {
//         images: { url: string }[];
//     };
//     name: string;
//     duration_ms: number;
//     artists: { name: string }[];
//     // Add other properties as needed
// }

// const TopArtists = () => {
//     const [tracks, setTracks] = useState<Track[]>([]);
//     const [artists, setArtists] = useState<Track[]>([]);
//     const [loading, setLoading] = useState(true);

//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 setLoading(true);
//                 const accessToken = await fetchAccessToken(clientId, clientSecret);
//                 const topTracksIds =  '4Lt6GXGzYsa1tgkv3nGSTm,0b6rUnRfjDuv60k5oWrCKa,4qlBvxOwFy6og73eik75Ro,580Rp3F98KrnHMdg8yoGvP,6G7Jnkix0H7nBxqjqGbD50';
//                 const response = await axios.get(
//                     `https://api.spotify.com/v1/tracks?ids=${topTracksIds}`,
//                     {
//                         headers: {
//                             'Authorization': `Bearer ${accessToken}`,
//                         },
//                     }
//                 );
//                 setTracks(response.data.tracks);
//                 setLoading(false);
//             } catch (error) {
//                 console.error('Error fetching recommended tracks:', error);
//                 setLoading(false);
//             }
//         };

//         fetchData();
//     }, [clientId, clientSecret]);
    

//     return (
//         <Box>
//             {loading ? (
//                 <div>Loading...</div>
//             ) : (
//                 <Box>
//                    {tracks.map((track, index) => (
//     <Box key={`${track.id}-${index}`} mb="4">
//         <TopArtistsCard
//             imageUrl={track.album.images[0].url}
//             artistName={track.artists[0].name}
//             noOfTracks={tracks.length}
//         />
//     </Box>
// ))}

//                 </Box>
//             )}


//         </Box>
//     );
// };

// export default TopArtists;
























// export const fetchSongsByGenre = async (genreId: string) => {
//   try {
//       const clientId = import.meta.env.VITE_CLIENT_ID;
//       const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//       const accessToken = await fetchAccessToken(clientId, clientSecret);

//       const response = await axios.get(
//           `https://api.spotify.com/v1/browse/categories/${genreId}/playlists`,
//           {
//               headers: {
//                   'Authorization': `Bearer ${accessToken}`,
//               },
//           }
//       );

//       if (!response.data || !response.data.playlists || !response.data.playlists.items) {
//           console.error('Unexpected response format:', response.data);
//           return [];
//       }

//       const playlists = response.data.playlists.items;

//       // Assuming you retrieve songs from the playlist
//       const songs = playlists.map((playlist: any) => ({
//           id: playlist.id,
//           name: playlist.name,
//           // Add more properties as needed
//       }));

//       console.log("Songs for genre ID", genreId, ":", songs);
//       return songs;
//   } catch (error) {
//       console.error('Error fetching songs:', error);
//       throw error;
//   }
// };









// import { Box, Image, Text } from '@chakra-ui/react';
// import React, { useEffect, useState } from 'react';
// import { useLocation, useNavigate, useParams } from 'react-router-dom';
// import { fetchSongsByGenre } from '../../AccessToken';

// const SongListsComp = () => {
//     const navigate = useNavigate();
//     const [songs, setSongs] = useState<any[]>([]);
//     const { genreId } = useParams<{ genreId: string }>();
//     const location = useLocation();
//     const queryParams = new URLSearchParams(location.search);
//     const name = queryParams.get('name') || 'Unknown Genre';
//     const imageUrl = queryParams.get('imageUrl');

//     useEffect(() => {
//         const fetchData = async () => {
//             try {
//                 if (genreId) {
//                     const fetchedSongs = await fetchSongsByGenre(genreId);
//                     setSongs(fetchedSongs);
//                 }
//             } catch (error) {
//                 console.error('Error fetching songs:', error);
//             }
//         };

//         fetchData();
//     }, [genreId]);

//     const handleSongClick = (songId: string) => {
//         // Navigate to another page with song details
//         navigate(`/song-details/${songId}`);
//     };

//     return (
//         <Box>
//             <Box className="">
//                 <Text>{name}</Text>
//                 {imageUrl && <Image src={imageUrl} alt={name} />}
//             </Box>
//             <ul>
//                 {songs.map(song => (
//                     <li key={song.id} onClick={() => handleSongClick(song.id)}>
//                         <Box display="flex" alignItems="center" mb={4}>
//                             <Image src={song.imageUrl} alt={song.name} width={100} height={100} borderRadius="md" mr={4} />
//                             <Box>
//                                 <Text fontWeight="bold">{song.name}</Text>
//                                 <Text>ID: {song.id}</Text>
//                             </Box>
//                         </Box>
//                     </li>
//                 ))}
//             </ul>
//         </Box>
//     );
// }

// export default SongListsComp;





















// export const fetchSongsInPlaylist = async (playlistId: string) => {
//   try {
//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//     const accessToken = await fetchAccessToken(clientId, clientSecret);

//     const response = await axios.get(
//       `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
//       {
//         headers: {
//           'Authorization': `Bearer ${accessToken}`,
//         },
//       }
//     );

//     if (!response.data || !response.data.items) {
//       console.error('Unexpected response format:', response.data);
//       return [];
//     }

//     const tracks = response.data.items;
//     console.log("tracks", tracks)

   

//     console.log("Songs in playlist", playlistId, ":", tracks);
//     return tracks;
//   } catch (error) {
//     console.error('Error fetching songs in playlist:', error);
//     throw error;
//   }
// };











// export const fetchSongsInPlaylist = async (playlistId: string) => {
//   try {
//     const clientId = import.meta.env.VITE_CLIENT_ID;
//     const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//     const accessToken = await fetchAccessToken(clientId, clientSecret);

//     const response = await axios.get(
//       `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
//       {
//         headers: {
//           'Authorization': `Bearer ${accessToken}`,
//         },
//       }
//     );

//     if (!response.data || !response.data.items) {
//       console.error('Unexpected response format:', response.data);
//       return [];
//     }

//     const tracks = response.data.items;
//     console.log("tracks", tracks);

//     const updatedTracks = tracks.map((track: any) => {
//       const imageUrl = track.track.album.images.length > 0 ? track.track.album.images[0].url : null;
//      console.log("imageurl", imageUrl);
//       return {
//         id: track.track.id,
//         name: track.track.name,
//         imageUrl: imageUrl,
//         // Add more properties as needed
//       };
//     });

//     console.log("Songs in playlist", playlistId, ":", updatedTracks);
//     return updatedTracks;
//   } catch (error) {
//     console.error('Error fetching songs in playlist:', error);
//     throw error;
//   }
// };










//accessToken.tsx

// export const fetchSongsByGenre = async (genreId: string) => {
//   try {
//       const clientId = import.meta.env.VITE_CLIENT_ID;
//       const clientSecret = import.meta.env.VITE_CLIENT_SECRET;
//       const accessToken = await fetchAccessToken(clientId, clientSecret);

//       const response = await axios.get(
//           `https://api.spotify.com/v1/browse/categories/${genreId}/playlists`,
//           {
//               headers: {
//                   'Authorization': `Bearer ${accessToken}`,
//               },
//           }
//       );

//       if (!response.data || !response.data.playlists || !response.data.playlists.items) {
//           console.error('Unexpected response format:', response.data);
//           return [];
//       }

//       const playlists = response.data.playlists.items;

//       // Fetch song images for each playlist and construct the songs array
//       const songs = await Promise.all(playlists.map(async (playlist: any) => {
//           // Fetch additional details for the playlist, including images
//           const playlistDetailsResponse = await axios.get(
//               `https://api.spotify.com/v1/playlists/${playlist.id}`,
//               {
//                   headers: {
//                       'Authorization': `Bearer ${accessToken}`,
//                   },
//               }
//           );

//           // Extract relevant data from the playlist details response
//           const playlistDetails = playlistDetailsResponse.data;

//           // Assuming playlist images are available in the playlistDetails.images array
//           const imageUrl = playlistDetails.images.length > 0 ? playlistDetails.images[0].url : null;

//           return {
//               id: playlist.id,
//               name: playlist.name,
//               imageUrl: imageUrl,
//               // Add more properties as needed
//           };
//       }));

//       console.log("Songs for genre ID", genreId, ":", songs);
//       return songs;
//   } catch (error) {
//       console.error('Error fetching songs:', error);
//       throw error;
//   }
// };















